// Win32Project1.cpp : 응용 프로그램에 대한 진입점을 정의합니다.
//

#include "stdafx.h"
#include "Win32Project1.h"

#define MAX_LOADSTRING 100

// 전역 변수:
HINSTANCE hInst;                                // 현재 인스턴스입니다.
WCHAR szTitle[MAX_LOADSTRING];                  // 제목 표시줄 텍스트입니다.
WCHAR szWindowClass[MAX_LOADSTRING];            // 기본 창 클래스 이름입니다.


// 이 코드 모듈에 들어 있는 함수의 정방향 선언입니다.
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);


int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

    // TODO: 여기에 코드를 입력합니다.

    // 전역 문자열을 초기화합니다.
    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadStringW(hInstance, IDC_WIN32PROJECT1, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    // 응용 프로그램 초기화를 수행합니다.
    if (!InitInstance (hInstance, nCmdShow))
    {
        return FALSE;
    }

    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WIN32PROJECT1));

    MSG msg;

    // 기본 메시지 루프입니다.
    while (GetMessage(&msg, nullptr, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return (int) msg.wParam;
}



//
//  함수: MyRegisterClass()
//
//  목적: 창 클래스를 등록합니다.
//
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WIN32PROJECT1));
    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_WIN32PROJECT1);
    wcex.lpszClassName  = szWindowClass;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

    return RegisterClassExW(&wcex);
}

//
//   함수: InitInstance(HINSTANCE, int)
//
//   목적: 인스턴스 핸들을 저장하고 주 창을 만듭니다.
//
//   설명:
//
//        이 함수를 통해 인스턴스 핸들을 전역 변수에 저장하고
//        주 프로그램 창을 만든 다음 표시합니다.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance; // 인스턴스 핸들을 전역 변수에 저장합니다.

   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      0, 0, 1024, 768, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd)
   {
      return FALSE;
   }

   g_hWnd = hWnd;

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
}

//
//  함수: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  목적:  주 창의 메시지를 처리합니다.
//
//  WM_COMMAND  - 응용 프로그램 메뉴를 처리합니다.
//  WM_PAINT    - 주 창을 그립니다.
//  WM_DESTROY  - 종료 메시지를 게시하고 반환합니다.
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	BezierCurves a;
	BezierCurve b1;
	Point2d pos;
    switch (message)
    {
	case WM_CREATE:		
		
		b1.BColor = BLACK;
		b1.isModifing = true;
		a.BezierAlphabet.push_back(b1);
		for (int i = 0; i < 26; i++)
		{
			a.AllocationAlphabet = AlphabetMap::AlphaBetA + i;			
			bezierContainer.push_back(a);
		}

		// color Dialog
		curRgb = 0x000000;
		ZeroMemory(&curPickColor, sizeof(curPickColor));
		curPickColor.lStructSize = sizeof(curPickColor);
		curPickColor.hwndOwner = hWnd;
		curPickColor.lpCustColors = (LPDWORD)acrCustClr;
		curPickColor.rgbResult = curRgb;
		curPickColor.Flags = CC_FULLOPEN | CC_RGBINIT;

		break;
	case WM_LBUTTONDOWN:
		pos.x = LOWORD(lParam);
		pos.y = HIWORD(lParam);
		bezierContainer[CurAllocAlpha].BezierAlphabet[CurActiveLineNumber].BCurve.push_back(pos);
		InvalidateRect(hWnd, 0, true);
		break;
	case WM_CHAR:
		switch (wParam)
		{
		case 'W':
		case 'w':
			xRatio += 0.5;
			yRatio += 0.5;
			break;
		case 'S':
		case 's':
			xRatio -= 0.5;
			yRatio -= 0.5;
			break;
		case 'A':
		case 'a':
			bezierContainer[CurAllocAlpha].BezierAlphabet[CurActiveLineNumber].isModifing = false;
			bezierContainer[CurAllocAlpha].BezierAlphabet[CurActiveLineNumber].BColor = curRgb;

			b1.BColor = curRgb;
			b1.isModifing = true;
			bezierContainer[CurAllocAlpha].BezierAlphabet.push_back(b1);			
			CurActiveLineNumber++;
			break;
		}		
		InvalidateRect(hWnd, 0, true);
		break;
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
			
            // 메뉴 선택을 구문 분석합니다.
            switch (wmId)
            {			
            case IDM_CHANGECHAR:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_DIALOG1), hWnd, About);
                break;
			case IDM_ADDCURVE:
				bezierContainer[CurAllocAlpha].BezierAlphabet[CurActiveLineNumber].isModifing = false;
				bezierContainer[CurAllocAlpha].BezierAlphabet[CurActiveLineNumber].BColor = curRgb;

				b1.BColor = curRgb;
				b1.isModifing = true;
				bezierContainer[CurAllocAlpha].BezierAlphabet.push_back(b1);
				CurActiveLineNumber++;
				break;
				break;
			case IDM_REMOVEONE:
				bezierContainer[CurAllocAlpha].BezierAlphabet[CurActiveLineNumber].BCurve.clear();
				InvalidateRect(hWnd, 0, true);
				break;
			case IDM_REMOVEALL:
				bezierContainer[CurAllocAlpha].BezierAlphabet.clear();
				CurActiveLineNumber = 0;
				b1.BColor = BLACK;
				bezierContainer[CurAllocAlpha].BezierAlphabet.push_back(b1);
				InvalidateRect(hWnd, 0, true);
				break;
			case IDM_REMOVELAST:
				bezierContainer[CurAllocAlpha].BezierAlphabet[CurActiveLineNumber].BCurve.pop_back();
				InvalidateRect(hWnd, 0, true);
				break;
			case IDM_LINE:
				bShowLine = !bShowLine;
				InvalidateRect(hWnd, 0, true);
				break;
			case IDM_PICKCOLOR:
				if (ChooseColor(&curPickColor) == true)
				{
					curRgb = curPickColor.rgbResult;
					InvalidateRect(hWnd, 0, true);
				}
				break;
			case IDM_CHANGEALPHA:
				DialogBox(hInst, MAKEINTRESOURCE(IDD_DIALOG1), hWnd, About);
				break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;
    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);
            // TODO: 여기에 hdc를 사용하는 그리기 코드를 추가합니다.
			DrawBezier(hdc,CurAllocAlpha);
            EndPaint(hWnd, &ps);
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}


// 정보 대화 상자의 메시지 처리기입니다.
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
	
    switch (message)
    {
    case WM_INITDIALOG:
		hwndCombo = GetDlgItem(hDlg, IDC_COMBO1);
		for (int i = 0; i < 26; i++)
		{
			SendMessage(hwndCombo, CB_ADDSTRING, 0,(LPARAM) Alphabet[i]);
		}
		SendMessage(hwndCombo, CB_SETCURSEL, (WPARAM) CurAllocAlpha, (LPARAM) 0);
        return (INT_PTR)TRUE;
		break;
    case WM_COMMAND:
		if (LOWORD(wParam) == IDC_COMBO1)
		{		
			if (HIWORD(wParam) == CBN_SELCHANGE)
			{
				int ItemIndex = SendMessage((HWND)hwndCombo, (UINT)CB_GETCURSEL,
					(WPARAM)0, (LPARAM)0);
				CurAllocAlpha = ItemIndex;
				CurActiveLineNumber = bezierContainer[CurAllocAlpha].BezierAlphabet.size() - 1;
				
			}
		}
        if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
        {
			InvalidateRect(g_hWnd, 0, true);
            EndDialog(hDlg, LOWORD(wParam));
            return (INT_PTR)TRUE;
        }
        break;
    }
    return (INT_PTR)FALSE;
}

void DrawBezier(HDC hdc, char AllocAlpha)
{
	int i;
	double t;
	BezierCurves cur = bezierContainer[CurAllocAlpha];

	// 벡터안에 저장되어 있을경우는 잘 됨.
	if (!cur.BezierAlphabet.empty())
	{
		vector<BezierCurve>::iterator it;
		for (it = cur.BezierAlphabet.begin(); it < cur.BezierAlphabet.end(); it++)
		{
			int degree = it->BCurve.size();
			for (t = 0.0; t < 1.0; t += 0.0005)
			{
				double xt = 0.0, yt = 0.0;
				for (int i = 0; i < degree; i++)
				{
					if (i == 0 || i == degree - 1)
					{
						xt += pow(t, i)  * pow(1 - t, degree - 1 - i) * (it->BCurve[0 + i].x * xRatio);
						yt += pow(t, i)  * pow(1 - t, degree - 1 - i) * (it->BCurve[0 + i].y * yRatio);
					}
					else
					{
						xt += (degree - 1) * pow(t, i)  *pow(1 - t, degree - 1 - i) * (it->BCurve[0 + i].x * xRatio);
						yt += (degree - 1) * pow(t, i)  *pow(1 - t, degree - 1 - i) * (it->BCurve[0 + i].y * yRatio);
					}
				}

				COLORREF usingColor = (it->isModifing ? curRgb : it->BColor);
				SetPixel(hdc, xt, yt, usingColor);
			}



			if (!it->BCurve.empty() && bShowLine)
			{
				vector<Point2d>::iterator pit;
				// 시작점으로 이동
				MoveToEx(hdc, it->BCurve[0].x * xRatio, it->BCurve[0].y * yRatio, NULL);
				for (pit = it->BCurve.begin(); pit < it->BCurve.end(); pit++)
				{
					LineTo(hdc, pit->x * xRatio, pit->y * yRatio);
				}
			}
		}
	}
}